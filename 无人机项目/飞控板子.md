主要控制文件介绍：

![](assets/硬件接线/file-20251208201110518.png)
# 飞控板：
Drivers/drv_Uart2.c
	接收 orangepi uart4发来的消息：1.路径列表，2.动物识别信息 
		1. src\uav_car\uav_car\navigator.py节点:fly_path_callback():ur.uart_sender4_send(self, msg)  **路径**发布 
		2. \uav_car\image_processor.py节点：sub_camera_callback():self.send_location(msg)   识别到动物停下扫描？

 **路径**格式：
+ 在 uav_car\uav_car\navigator.py: fly_path_callback()末尾有介绍，例如msg=‘@1:<长度>;x1,y1;x2,y2;......;#’
+ 后续格式变化： 
	+ 先 msg = " ".join(format(ord(d), '02X') for d in str(msg))
	+ 再 ur.uart_sender4_send(self, msg)   
	+ 

Drivers/drv_Uart7.c
	接收 orangepi uart3发来的消息：1. 起飞讯号 2. xyz水平+高度数据
		1. UAV_CAR\src\uav_car\uav_car\navigator.py: takeoff_callback():ur.uart_sender3_send(self, msg) 起飞信息：'52<空格>'
		2. UAV_CAR\src\uav_car\uav_car\t265.py: service_t265_open_callback()->timer_pub_t265_callback(): ur.uart_sender3_send(self, t265_date) t265+定高信息： 

Drivers/drv_main.c
# 硬件初始化汇总

Modes/M37.c




# 飞控香橙派：

发送消息，全靠 service 和 topic！

## 水平和定高数据 转发给飞控板！

拿 **香橙派飞行端 uart4发送 xyz数据**来说：**uart_sender4_data_topic**这个话题作为中转站
	1. navigator.py节点调用uart_sender4_init()创建 publisher发布者，使用\uav_car_unit\utils_ros.py: ur.uart_sender4_send()方法，发布数据到 话题**uart_sender4_data_topic**
	2. 另一端，这个话题的订阅者节点uart_sender4.py早在程序启动时，就已经初始化：uav_car\uart_sender4.py：uartSender = us.UartSender("uart_sender4", "/dev/ttyS4", 57600, 5) 
	3. us即为  import uav_car_unit.uart_sender as us， 最后可以看到，在UartSender类中调用串口发送给**飞控板子**
	4. 总结： 并行创建 串口数据的发布者+订阅者， 发布者从传感器读数据，发布到话题，订阅者读话题，然后 从串口写给飞控！
```python
UAV_CAR\src\uav_car_unit\uav_car_unit\uart_sender.py：
uart_sender结构如下：
class UartSender(Node):  
    '''飞行端订阅者： 订阅飞行端自己的数据发布者，然后回调转发数据给串口'''

    def __init__(self, name, serial_port, baudrate, topic_stack=50):

        super().__init__(name) # FIXME 串口基类：波特率 串口号
        self.name = name
        self.topic_stack = topic_stack
        self.sub = self.create_subscription(String, name + "_data_topic", self.send_uart_data, topic_stack) # FIXME 串口基类：订阅者回调！！！！！！
        self.serial_port = serial_port
        self.baudrate = baudrate
        self.sink_serial = serial.Serial(self.serial_port, self.baudrate)
        self.get_logger().warning(f"init success")

    def send_uart_data(self, msg):
        self.get_logger().info(f"request to send:{msg.data}")
        if self.sink_serial.isOpen():
            hex_msg = bytes.fromhex(msg.data) # FIXME 串口基类：hex转bit
            send_count = self.sink_serial.write(hex_msg)
            if send_count == len(hex_msg): return True 
            else:                          return False
```
	


## T265Data 发布给 飞行端其他程序 以及 地面站（不转发给飞控板！）

不同于上述过程，UAV_CAR\src\uav_car\uav_car\t265.py 节点 也创建了一个**t265_data_topic**的话题，发布的数据为**T265Data**。

self.create_publisher(**T265Data**, name + '_data_topic', topic_stack)，这里 name='t265'

**t265_data_topic**话题有几个作用：
1. 发布t265+激光定高数据，也即 **T265Data**
2. \uav_car\image_processor.py图像识别节点，订阅该话题的数据**T265Data**，
3. 同样，地面站那边，也订阅**t265_data_topic**这个话题，更新飞机的飞行轨迹
---

类似于 **t265_data_topic**，飞行端还有其他的发布者：

+  位于uav_car_unit\camera.py 节点的发布者**camera__data_topic** （不是UDP话题），负责程序间通信，传图给 uav_car\image_processor.py节点下的rknn图像处理订阅者 ，回调sub_camera_callback，进行动物识别，识别到后send_location->调用t265_data_to_uart_std ->然后ur.uart_sender4_send(self, msg) 发布信息给 **uart_sender4_data_topic**， 完成给飞控板转发数据。

+ 位于 **地面站！的** 话题**udp_info_topic**， 地面站创建了一个发布者**udp_info_publisher**， 而飞行端在uav_car\image_processor.py节点创建了订阅者**sub_udp_info**， 接收地面站发来的 ip地址，并**回传UDP图像**


+ 位于 uav_car\image_processor.py节点的
