主要控制文件介绍：

![](assets/硬件接线/file-20251208201110518.png)
# 飞控板：
Drivers/drv_Uart2.c
	接收 orangepi uart4发来的消息：1.路径列表，2.动物识别信息 
		1. src\uav_car\uav_car\navigator.py:func:fly_path_callback():ur.uart_sender4_send(self, msg)  路径发布 
		2. src\uav_car\uav_car\image_processor.py：func:sub_camera_callback():self.send_location(msg)   识别到动物停下扫描？

1. 路径消息格式：
+ 在 uav_car\uav_car\navigator.py: fly_path_callback()末尾有介绍，例如msg=‘@1:<长度>;x1,y1;x2,y2;......;#’
+ 后续格式变化： 
	+ 先 msg = " ".join(format(ord(d), '02X') for d in str(msg))
	+ 再 ur.uart_sender4_send(self, msg)   
	+ 

Drivers/drv_Uart7.c
	接收 orangepi uart3发来的消息：1. 起飞讯号 2. xyz水平+高度数据
		1. UAV_CAR\src\uav_car\uav_car\navigator.py: takeoff_callback():ur.uart_sender3_send(self, msg) 起飞信息：'52<空格>'
		2. UAV_CAR\src\uav_car\uav_car\t265.py: service_t265_open_callback()->timer_pub_t265_callback(): ur.uart_sender3_send(self, t265_date) t265+定高信息： 

Drivers/drv_main.c
# 硬件初始化汇总

Modes/M37.c




# 飞控香橙派：

发送消息，全靠 service 和 topic！

## 水平和定高数据发布给飞控板！
	拿 **香橙派飞行端 uart4发送 xyz数据**来说：**uart_sender4_data_topic**这个话题作为中转站
		1. navigator.py节点调用uart_sender4_init()创建 publisher发布者，使用\uav_car_unit\utils_ros.py ur.uart_sender4_send()方法，发布数据到 话题**uart_sender4_data_topic**
		2. 另一端，这个话题的订阅者节点uart_sender4.py早在程序启动时，就已经初始化：uav_car\uart_sender4.py：uartSender = us.UartSender("uart_sender4", "/dev/ttyS4", 57600, 5) 
		3.   us即为  import uav_car_unit.uart_sender as us
```python
UAV_CAR\src\uav_car_unit\uav_car_unit\uart_sender.py：
uart_sender结构如下：
class UartSender(Node):  
    '''飞行端订阅者： 订阅飞行端自己的数据发布者，然后回调转发数据给串口'''

    def __init__(self, name, serial_port, baudrate, topic_stack=50):

        super().__init__(name) # FIXME 串口基类：波特率 串口号
        self.name = name
        self.topic_stack = topic_stack
        self.sub = self.create_subscription(String, name + "_data_topic", self.send_uart_data, topic_stack) # FIXME 串口基类：订阅者回调！！！！！！
        self.serial_port = serial_port
        self.baudrate = baudrate
        self.sink_serial = serial.Serial(self.serial_port, self.baudrate)
        self.get_logger().warning(f"init success")

    def send_uart_data(self, msg):
        self.get_logger().info(f"request to send:{msg.data}")
        if self.sink_serial.isOpen():
            hex_msg = bytes.fromhex(msg.data) # FIXME 串口基类：hex转bit
            send_count = self.sink_serial.write(hex_msg)
            if send_count == len(hex_msg): return True 
            else:                          return False
```
		4. 最后可以看到，在这里进行了串口发送
		5. 总结： 并行创建 串口数据的发布者+订阅者， 发布者从传感器读数据，发布到话题，订阅者读话题，然后 从串口写给飞控！


## t265数据发布给 飞行端其他程序 以及 地面站

不同于上述过程，UAV_CAR\src\uav_car\uav_car\t265.py 节点 也创建了一个t265_data_topic的话题。

self.create_publisher(T265Data, name + '_data_topic', topic_stack)

这个话题有几个作用：
1. 发布t265+激光定高数据
2. \uav_car\image_processor.py图像识别节点，订阅该话题的数据**T265Data**，