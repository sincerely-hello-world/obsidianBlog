主要控制文件介绍：

![](assets/硬件接线/file-20251208201110518.png)
# 飞控板：
Drivers/drv_Uart2.c
	接收 orangepi uart4发来的消息：1.路径列表，2.动物识别信息 
		1. src\uav_car\uav_car\navigator.py节点:fly_path_callback():ur.uart_sender4_send(self, msg)  **路径**发布 
		2. \uav_car\image_processor.py节点：sub_camera_callback():self.send_location(msg)   识别到动物发坐标给飞控板？/地面站？

 **路径**格式：
+ 在 uav_car\uav_car\navigator.py: fly_path_callback()末尾有介绍，例如msg=‘@1:<长度>;x1,y1;x2,y2;......;#’
+ 后续格式变化： 
	+ 先 msg = " ".join(format(ord(d), '02X') for d in str(msg))
	+ 再 ur.uart_sender4_send(self, msg)   
	+ 

Drivers/drv_Uart7.c
	接收 orangepi uart3发来的消息：1. 起飞讯号 2. xyz水平+高度数据
		1. UAV_CAR\src\uav_car\uav_car\navigator.py: takeoff_callback():ur.uart_sender3_send(self, msg) 起飞信息：'52<空格>'
		2. UAV_CAR\src\uav_car\uav_car\t265.py: service_t265_open_callback()->timer_pub_t265_callback(): ur.uart_sender3_send(self, t265_date) t265+定高信息： 

Drivers/drv_main.c
	硬件初始化汇总

Modes/M37.c
	起飞，
	起飞之后的飞控逻辑




# 飞行端香橙派：

发送消息，全靠 service 和 topic！

## 水平和定高数据 转发给飞控板！

拿 **香橙派飞行端 uart3发送 xyz数据**来说：**uart_sender3_data_topic**这个话题作为中转站
	1. navigator.py节点调用ur.uart_sender3_init()创建 publisher发布者，同时也创建了**uart_sender3_data_topic**这个话题
	2. 使用ur.uart_sender3_send()函数(未作处理，字符串发送)发布数据到 话题**uart_sender3_data_topic**
	3. 
	4. 另一端，**uart_sender3_data_topic**话题的订阅者，所在的节点**uart_sender3.py**也在并行运行，订阅着该话题消息：uav_car\uart_sender3.py：uartSender = us.UartSender("uart_sender3", "/dev/ttyS3", 57600, 5) 
	5. us即为  import uav_car_unit.uart_sender as us， 可以看到在UartSender类中调用串口**serial**方法发送给**飞控板子**
	6. 总结： 并行创建 串口数据的发布者+订阅者， 发布者从传感器读数据，发布到话题，订阅者读话题，然后 从串口写给飞控！


调用串口**serial**方法发送给**飞控板子**数据：
```python
uav_car_unit\uart_sender.py：uart_sender结构如下：uart_sender结构如下：
class UartSender(Node):  
    '''飞行端订阅者： 订阅飞行端自己的数据发布者，然后回调转发数据给串口'''

    def __init__(self, name, serial_port, baudrate, topic_stack=50):

        super().__init__(name) # FIXME 串口基类：波特率 串口号
        self.name = name
        self.topic_stack = topic_stack
        self.sub = self.create_subscription(String, name + "_data_topic", self.send_uart_data, topic_stack) # FIXME 串口基类：订阅者回调！！！！！！
        self.serial_port = serial_port
        self.baudrate = baudrate
        self.sink_serial = serial.Serial(self.serial_port, self.baudrate)
        self.get_logger().warning(f"init success")

    def send_uart_data(self, msg):
        self.get_logger().info(f"request to send:{msg.data}")
        if self.sink_serial.isOpen():
            hex_msg = bytes.fromhex(msg.data) # FIXME 串口基类：hex转bit
            send_count = self.sink_serial.write(hex_msg)
            if send_count == len(hex_msg): return True 
            else:                          return False
```
	

飞行端主要文件即为  UAV_CAR\src\uav_car\uav_car\的py节点文件， 被 launch脚本一起启动。

飞行端 uart3相同的发送逻辑，在

## T265Data 航迹信息发布（不转发给飞控板！）

不同于上述过程，UAV_CAR\src\uav_car\uav_car\t265.py 节点 也创建了一个**t265_data_topic**的话题，发布的数据为**T265Data**。

self.create_publisher(**T265Data**, name + '_data_topic', topic_stack)，这里 name='t265'

**t265_data_topic**话题有几个作用：
1. 发布t265+激光定高数据，也即 **T265Data**
2. \uav_car\image_processor.py图像处理节点，订阅该话题的数据**T265Data**，
3. 同样，**地面站**也订阅**t265_data_topic**这个话题，更新显示屏上的飞机飞行轨迹
---

## 类似于 **t265_data_topic**，还有其他的发布者：

## UDP图传
+ 位于 **地面站！的** 话题**udp_info_topic**， 地面站创建了它的发布者**udp_info_publisher**， 而飞行端在uav_car\image_processor.py节点创建了订阅者**sub_udp_info**， 接收地面站发来的 ip地址，并在**udp_info_callback**解析，创建**udp_sender**回传UDP图像。

---
## 图像传递和RKNN识别
+  位于飞行端 uav_car_unit\camera.py 节点的话题**camera_data_topic** 发布者pub_camera（不是UDP话题发布者），负责读取摄像头信息，被uav_car\image_processor.py节点下的**sub_camera**订阅者摄像头图像，回调**sub_camera_callback**，进行rknn图像处理 ：
	1. 进行动物识别，识别到后**send_location**：
			->调用t265_data_to_uart_std ->然后ur.uart_sender4_send(self, msg) 发布信息给 **uart_sender4_data_topic**， 完成给飞控板转发数据；
			-> 调用 **pub_image_processor**.publish(animal_msg)发送动物识别信息
			
	2. 同时也调用 转发识别后的图像给UDP端口！
---

## 动物识别信息发布
+ 位于飞行端 uav_car\image_processor.py节点的话题**image_processor_topic**，有**pub_image_processor** 发布ImageProcessorData动物识别结果，然后被**地面站**animal_sub**订阅。


+ 位于 uav_car\image_processor.py节点的
