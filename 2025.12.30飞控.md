

```c
#include "M37.h"
// #include "Control_Liu.h"
#include "drv_Uart7.h"
#include "drv_Uart2.h"
#include <math.h>
#include "pid.h"
#include <stdint.h>

// #include "drv_I2C1.h"

/*lhq如果其他文件中也有一个名为count的变量，那么它们不会相互冲突，因为每个文件中的count都是独立的，只对本文件可见。*/
static float pos[4];

float mark_x;
float mark_y;
float mark_z;
float mark_zt;

//extern tPid pidMotorSpeed;
//extern tPid pidMotorAngle;

extern float t265_x;
extern float t265_y;
extern float t265_z; // 引入的t265数据
extern int T265_is_ready;
 
extern bool yaw_liscence;

static int vol = 2;        // 加速起飞，积分量
static float now_volz = 0; // 现在V_z的速度
static float now_volx = 0; // 现在V_x速度
static float now_voly = 0; // 现在V_y速度
static double now_yaw;  // 现在yaw角度
 

// uint8_t a = 10;
static void M37_Liu_MainFunc();
static void M37_Liu_enter();
static void M37_Liu_exit();

// 当前位置信息
extern volatile vector3_float Position_data;

/*lhq*/
const Mode M37_Liu = {
    50,               // 模式运行频率
    M37_Liu_enter,    // 进入模式触发函数
    M37_Liu_exit,     // 离开模式触发函数
    M37_Liu_MainFunc, // 模式主函数（运行频率执行）
};
typedef struct
{
    // 退出模式计数器
    uint16_t exit_mode_counter;

    bool start_Lock;

    float target_x;
    float target_y;
    float target_z; // 目标坐标坐标

    float target_yaw; // 目标偏航

    bool position_lock; // xy位置锁定
    bool height_lock;   // z位置锁定
    bool yaw_lock;      // yaw角锁定

    int zhu_distance; // 柱子间的距离

    int zt; // 任务状态

    int listen; // 聆听任务状态，用于观察Jetson执行到哪一步了

    int count; // 50Hz 1s计数50下，用于摇晃飞机 //初始化状态用到了

    int delay_count; // 延迟计数器 //用完记得归零
} MODE_INF;
static MODE_INF *Mode_Inf; // 指针

// 功能函数说明
/************************************************************************************************/

static void ALL_Enable(); // 所有控制权限开放

static bool Lock_position(float x, float y); // 位置锁定
static bool Lock_position_same();            // 原位锁定
static bool Lock_h(float height);            // 高度锁定
static bool Lock_h_same();                   // 原高锁定
static bool Lock_yaw_same();                 // 原yaw角锁定
static bool Lock_yaw(float aim_yaw);
static bool UnLock_position(); // 位置解锁
static bool UnLock_h();        // 高度解锁
static bool UnLock_yaw();      // yaw解锁

// static bool H_cushion();                                                       //H缓冲函数
static bool Takeoff_Initial(float height);                                        // 起飞初始化函数
static bool Takeoff_h(float height, int v);                                       // 高度锁定起飞
static bool Takeoff_h_45d(float height, uint8_t sign_x, uint8_t sign_y, float v); // 45度角起飞

static int8_t Fast_Takeoff(float band, float v_begin); // 快速起飞

static bool Move_to_X(float x, float v, uint8_t clear_count);                     // 直线X移动
static uint8_t Move_to_X_coll(float x, float v);                                  // 直线X移动协作函数
static bool Move_to_Y(float y, float v, uint8_t clear_count);                     // 直线Y移动
static uint8_t Move_to_Y_coll(float y, float v);                                  // 直线Y移动协作函数
static bool Move_to_XYLine(float x, float y, float v);                            // 线性移动到XY某位置
static uint8_t Move_to_XYLine_coll(float x, float y, float v, float detail);      // 线性移动到XY某位置协作函数
static int8_t Move_to_XYLine_smoth_coll(float x, float y, float v, float detail); // 线性移动到XY某位置平滑函数
static bool Move_Z(float z, float v);                                             // 改变Z位置到z;
static bool RotateToYaw(float aim_yaw, float max_yaw_rate);

static uint8_t Move_xyz(float x, float y, float z, float v); // 目标XYZ移动

static bool Huanxian(float max_x, float max_y, uint8_t use_taskid, float v); // 环线
static bool Though_Line(float *pos, float v);                                // 穿圈
static bool Though_Line_happy(float *pos_main, float v);                     // 傻瓜式穿圈

static bool Fast_Circle2(float o_x, float o_y, float r, float yaw_v, int8_t taskbreak); // 快速绕圈2 定义圆心,半径,速度

static bool Rotate(float aim_yaw, float v_yaw); // 自旋到规定角度

static bool Land(float v); // 降落仅有速度版

static bool Takeoff_h(float height, int v);
static int8_t Takeoff(float x, float y, float z, float v);

 
static bool FlyAgain(float v);
static bool Landstop(float v);
 
/*************************************************************************************************/

/*static void M37_Liu_enter()函数通过加上static关键字，确保了这个函数只能在本文件中使用，不会与其他文件中的函数名冲突，同时也表明了这个函数是文件私有的，不会被外部模块调用，有助于保持代码的整洁和模块化。*/
static void M37_Liu_enter()
{
    Led_setStatus(LED_status_running1); // 红绿蓝闪烁

    // Initialize Variable Mode_Inf

    Mode_Inf = malloc(sizeof(MODE_INF));
    Mode_Inf->exit_mode_counter = 0;

    Mode_Inf->start_Lock = false; // 启动锁锁住

    Mode_Inf->target_x = 0.0f;
    Mode_Inf->target_y = 0.0f;
    Mode_Inf->target_z = 0.0f; // 目标位置初始化

    Mode_Inf->target_yaw = 0.0f; // 目标yaw角

    Mode_Inf->zhu_distance = 0.0f; // 绕柱子目标初始化

    Mode_Inf->zt = 0;     // 初始化任务状态为0
    Mode_Inf->listen = 0; // 初始化Jetson观察状态为0

    Mode_Inf->height_lock = false;
    Mode_Inf->position_lock = false; // 关闭高度锁和位置锁
    Mode_Inf->yaw_lock = false;      // 关闭偏转角锁

    Mode_Inf->count = 0;

    // TODO  结构体 新增成员变量
    Mode_Inf->delay_count = 0;
    //Position_Control_Enable(); //?lhq没看懂

}

static void M37_Liu_exit()
{
    Position_Control_Disable();
    Altitude_Control_Disable();
    free(Mode_Inf);
}

extern int listen_ready;


// #define TAKEOFF_HEIGHT 100.0f
// #define HEIGHT         100.0f

#define TAKEOFF_HEIGHT 55.0f
#define HEIGHT 55.0f

#define MAP_SPEED 50.0f
#define FIRE_SPEED 30.0f

// 常量定义（根据实际调试调整）
const float SLOW_DOWN_DIST = 30.0f; // 开始减速的距离阈值
const float STOP_DIST = 6.0f;       // 完全停止的距离阈值
const float MIN_SPEED = 6.0f;       // 最小速度限制
const float MAX_ACCEL = 8.0f;       // 最大加速度限制

// ENU坐标转换为BodyHeading（x为机头朝向（与地面平行），y为朝向机头左方（与地面平行），z为上方）
#define map_ENU2BodyHeading_x(enu_x, enu_y, Yaw_sin, Yaw_cos) (enu_x * Yaw_cos + enu_y * Yaw_sin)
#define map_ENU2BodyHeading_y(enu_x, enu_y, Yaw_sin, Yaw_cos) (-enu_x * Yaw_sin + enu_y * Yaw_cos)
// BoduHeading转换为ENU坐标
#define map_BodyHeading2ENU_x(body_x, body_y, Yaw_sin, Yaw_cos) (body_x * Yaw_cos - body_y * Yaw_sin)
#define map_BodyHeading2ENU_y(body_x, body_y, Yaw_sin, Yaw_cos) (body_x * Yaw_sin + body_y * Yaw_cos)

//extern float detect_x, detect_y, detect_z;
//extern int gofly;
//extern int backfly;
//extern int points[50][2];
//extern int point_count;


static int cs = 0;
static float now_x = 0, now_y = 0, now_fire_x = 0, now_fire_y = 0, delta_bood_x = 0, delta_bood_y = 0;
static float bood_vx = 20.0f;
static float bood_vx_slow_flag = false;
static int bood_slow_count = 0;
static bool now_liscence = false;
static bool success_now_liscence = false;
static bool now_fire_liscence = false;
 
static uint8_t clear_count = 0;
static int saved_cs = 0;
static bool returning_to_route = false;

volatile uint8_t dot_now = 0;
uint8_t dot_back_now = 0;
int Dot_X, Dot_Y = 0;
int Dot_X_OLD, Dot_Y_OLD = 25;
 
 
 
//uart2 变量           
extern float zx_x;
extern float zx_y;
extern float detect_x,detect_y,detect_z;
extern unsigned char landflag;
extern int gofly;
extern int backfly;
extern int point_count; // 点的数量
extern int points[50][2]; // 假设最多50个点，每个点有x和y坐标

//uart7 变量
extern float t265_x;
extern float t265_y;
extern float t265_z;
extern int T265_is_ready; //起飞信号！


int Fx[] = {25, 250, 250, 25, 25}; //正非
int Fy[] = {25, 25, 325, 325, 25};
////////////0    1      2    3   4
//int Fx[] = {25, -225, -225, 25,  25}; //逆着非
//int Fy[] = {25, 25,   -225, -225, 25};

float init_yaw_value();

static void M37_Liu_MainFunc()
{
    if (Mode_Inf->start_Lock == false)                                       // XXX   解锁飞控
    {                                                                        // [ ] A  初始化： PID参数初始化,解锁飞行权
        if (fabs(t265_x - 25) < 10 && fabs(t265_y - 25) < 10 && t265_z < 10) // 相对坐标
        {
            if (t265_x != 0 || t265_y != 0 || t265_z != 0)
            { // 起飞许可
                if (T265_is_ready == 1)
                { // T265_is_ready 来自 uart7: 收到t265校准确认/起飞指令 <0x52> ， 才被置为1
                    Mode_Inf->start_Lock = true;
									  landflag=0; //不进行降落
                }
            }
        }
    }
		else if(Mode_Inf->start_Lock == true && Mode_Inf->count != -1){ //起飞前延时 最后检查
		    Mode_Inf->count++;
        if (Mode_Inf->count < 150)
        {
            Led_setSignal(LED_signal_success); // 警告警告，我要起飞了！
        }
        else if (Mode_Inf->count >= 150) // 20ms*150 = 3000ms = 3s秒后起飞
        {
            Position_Control_Enable();   // 位置控制使能
            Led_setSignal(LED_signal_null);
						Mode_Inf->count = -1;
        }
		}
		else if ( landflag == 1  ){ //收到紧急降落 软件指令， 降落1
							Land(40);
		}
    else if(Mode_Inf->count == -1) //状态机飞行状态 
    {
        switch (Mode_Inf->zt){ //[ ] B 状态切换任务控制
					case 0:
					{ // XXX   进入起飞流程：初始化
							Takeoff_Initial(TAKEOFF_HEIGHT);
							break;
					}
					case 1: // 起飞部分 // XXX   进入起飞流程：起飞
					{
							Takeoff_h(HEIGHT, 40);
							break;
					}

//					case 2:
//					{ // 悬停6s 然后降落
//							Mode_Inf->delay_count++;
//							if (150 < Mode_Inf->delay_count) // 悬停3s = 3000ms = 20ms * 150
//							{
//									Mode_Inf->delay_count = 0; // 清零计数
//									Mode_Inf->zt = 3;          // 跳转到降落
//							}
//							break;
//					}
//					case 3:
//					{ // 矩形飞行
//							static uint8_t i = 0;
//							if (Move_to_XYLine(Fx[i], Fy[i], 30) == true)
//							{
//									++i; //有效坐标序号4 ，因而是 5 停止！
//									if (i >= 5)
//									{
//											Mode_Inf->zt = 7; // 跳转到降落
//									}
//							}
//							break;
//					}

            case 2: // 前往拐点部分
            {
                if (cs == 0) {
                    Dot_X = points[0][0];
                    Dot_Y = points[0][1];
                    cs++;
                    Mode_Inf->zt++;
                }
                break;
            }
            case 3: // 前往动物部分
            {
                static uint8_t state = 0;
                static uint8_t clear = 0;
//              if (gofly == 1) {
//                    if (state == 0) {
//                        if (Move_to_XYLine(zx_x, zx_y, 30) == true) // 距离远 更快， 节省时间；避免过充
//                        {// zx_x=detect_x;  动物位置上方x		zx_y=detect_y; //动物位置上方y //zx_x zx_y在uart2有写
//                            state   = 1; //到达了标记的动物位置
//                            backfly = 0;
//                        }
//                    } else { //这时，到达了动物上方附近， 等待orangepi的激光扫描
//                        if (backfly == 1) // 串口 收到@4#，可以离开，清除状态位
//                        {
//                            gofly   = 0;// 不需要在此停留了，回到折线航迹，继续飞
//                            backfly = 0;
//                            state   = 0;
//                            clear   = 1;
//                        }
//                    }
//                }
//								else
								{
										
//                    if (Dot_X == Dot_X_OLD) {
//                        if (Move_to_Y(Dot_Y, 25, clear) == true) {
//                            Dot_X_OLD = Dot_X;
//                            Dot_Y_OLD = Dot_Y;
//                            Dot_X     = points[cs][0];
//                            Dot_Y     = points[cs][1];
//                            cs++;
//                        }
//                        if (clear == 1)
//                            clear = 0;
//                    } else if (Dot_Y == Dot_Y_OLD) {
//                        if (Move_to_X(Dot_X, 25, clear) == true) {
//                            Dot_X_OLD = Dot_X;
//                            Dot_Y_OLD = Dot_Y;
//                            Dot_X     = points[cs][0];
//                            Dot_Y     = points[cs][1];
//                            cs++;
//                        }
//                        if (clear == 1)
//                            clear = 0;
//                    }
										
										if(Move_to_XYLine(Dot_X,Dot_Y,25)==true) {
														Dot_X_OLD = Dot_X;
                            Dot_Y_OLD = Dot_Y;
                            Dot_X     = points[cs][0];
                            Dot_Y     = points[cs][1];
                            cs++;
										}
										
                    if (cs >= point_count) {
                        Mode_Inf->zt = 6;
                        Led_setStatus(LED_status_running1);
                    }
                }
                break;
            }
            case 4: {
                break;
            }
            case 5: {
                break;
            }
            case 6: // 飞回原点
            {
                if (Move_xyz(25, 25, 0, 30) == 2) {
                    Mode_Inf->zt++;
                }
                break;
            }
					case 7:
					{
							Land(40);
							break;
					}
					case 8:
					{
							break;
					}
        }//end of switch 
        //-----------------------------------------------------
        // 以上为状态切换

        //-----------------------------------------------------
        if (Mode_Inf->position_lock == true)
        { //  悬停在XY，如果有飘逸，P校准归位。
            float delta_x = Mode_Inf->target_x - t265_x;
            float delta_y = Mode_Inf->target_y - t265_y;

            if (fabsf(delta_x) > STOP_DIST)
            {
							now_volx = delta_x * 1.5;
							now_volx = fabsf(now_volx) > 20 ? sign_f(now_volx)*20 : now_volx ; //避免超调
//                if (fabsf(now_volx) < 10)
//                {
//                    now_volx = delta_x * 2;
//                }
//                else if (fabsf(now_volx) < 20)
//                {
//                    now_volx = delta_x * 1.5;
//                }
            }else{ now_volx = delta_x; }
						
            if (fabsf(delta_y) > STOP_DIST)
            {
								  now_voly = delta_y * 1.5;
									now_voly = fabsf(now_voly) > 20 ? sign_f(now_voly)*20 : now_voly ; //避免超调
//                if (fabsf(now_voly) < 10)
//                {
//                    now_voly = delta_y * 2;
//                }
//                else if (fabsf(now_voly) < 20)
//                {
//                    now_voly = delta_y * 1.5;
//                }
            }else{ now_voly = delta_y; }
            Position_Control_set_TargetVelocityXY(now_volx, now_voly); // 速度值： -25~-10  10~25 合适区间
        }

        if (Mode_Inf->height_lock == true)
        { // 维持高度
            now_volz = 2.0 * (Mode_Inf->target_z - t265_z);
            Position_Control_set_TargetVelocityZ(now_volz);
        }
        //				if (Mode_Inf->yaw_lock == true) { // 维持航向
        //					  float now_yaw = Quaternion_getYaw(get_Airframe_attitude());
        //						float delta_yaw = Mode_Inf->target_yaw - now_yaw;
        //						if (fabsf(delta_yaw) > 0.2f ) { // 约5度
        //								Attitude_Control_set_Target_Yaw(Mode_Inf->target_yaw);
        //					   }
        //					}
    } // end of else !
}

//------------------------------------------------------------
// 以下为所需函数

/*******************************************
函数名：Move_to_XYLine
作用：xy平面最短距离移动_线性
作者：Lcs
输入参数：float x 目标x位置 float y 目标y位置 float v 速度
输出参数：bool 是否到位
封装等级：3
*******************************************/
static bool Move_to_XYLine(float x, float y, float v)
{
    static uint8_t l_step = 0;
    float delta_x = x - t265_x;
    float delta_y = y - t265_y;
    float distance = sqrt(delta_x * delta_x + delta_y * delta_y);
    float vx = v, min_vx = MIN_SPEED;
    float vy = v, min_vy = MIN_SPEED;
    if (delta_x < 0)
    {
        vx = -v;
        min_vx = -MIN_SPEED;
    }
    if (delta_y < 0)
    {
        vy = -v;
        min_vy = -MIN_SPEED;
    }

    if (l_step == 0)
    {
        UnLock_position();
        Mode_Inf->target_x = x;
        Mode_Inf->target_y = y;
        now_volx = 0;
        now_voly = 0;
        Position_Control_set_TargetVelocityXY(0, 0);
        l_step++;
        return false;
    }
    else if (l_step == 1)
    {
        // 改动2
        //  根据距离动态调整速度 xxxxxx
        if (fabsf(delta_x) > SLOW_DOWN_DIST)
        {
            // 远距离保持设定速度
            now_volx += 0.2f * (vx - now_volx); // 改动2 x // 可调：0.01~0.2附近，越小越平滑 sign_f(delta_vx)
        }
        else if (fabsf(delta_x) > STOP_DIST)
        {
            // 减速区：速度随距离线性减小
            if(fabsf(now_volx) > 2*MIN_SPEED  )now_volx += 0.2f * (min_vx - now_volx); // 改动1 x
					  else      								now_volx  = min_vx * 1.5;
        }
        else
        {
            //近距离：暂停
					  now_volx =0;
        }

        // 根据距离动态调整速度 yyyyyy
        if (fabsf(delta_y) > SLOW_DOWN_DIST)
        {
            // 远距离保持设定速度
            now_voly += 0.2f * (vy - now_voly); // 改动1 x // 可调：0~1，越小越平滑 一阶线性滤波
        }
        else if (fabsf(delta_y) > STOP_DIST)
        {
            // 减速区：速度随距离线性减小
            if(fabsf(now_voly) > 2*MIN_SPEED  )now_voly += 0.2f * (min_vy - now_voly); // 改动1 x
					  else      							 now_voly  = min_vy * 1.5;
        }
        else
        {
            //近距离：暂停
					  now_voly =0;
        }

        if (distance < STOP_DIST) // 达到接受距离 直接锁定位置
        {
            l_step = 0; // 结束控制，重置状态
            Mode_Inf->target_x = x;
            Mode_Inf->target_y = y;
            Lock_position_same();
            Lock_h_same();
            return true;
        }
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
    }
    return false;
}

/*******************************************
函数名：Move_to_X
作用：x移动_线性
作者：Lcs
输入参数：float x 目标x位置float v 速度
输出参数：bool 是否到位
封装等级：3
*******************************************/
static bool Move_to_X(float x, float v, uint8_t clear) // 输入速度v永远是 +++++！
{
    static uint8_t lx_step = 0;
    float delta_x = x - t265_x;
    float delta_y = Mode_Inf->target_y - t265_y;
    //    now_voly               = delta_y * 1.5;
    // 常量定义（根据实际调试调整）
    //    const float SLOW_DOWN_DIST = 30.0f; // 开始减速的距离阈值
    //    const float STOP_DIST      = 5.0f;  // 完全停止的距离阈值
    //    const float MIN_SPEED      = 3.0f;  // 最小速度限制
    //		const float MAX_ACCEL      = 8.0f;  // 最大加速度限制
    float min_v = MIN_SPEED;
    // 方向处理
    if (delta_x < 0)
    {
        v = -v;
        min_v = -MIN_SPEED;
    }

    if (clear == 1)
        lx_step = 0;

    if (lx_step == 0)
    {
        UnLock_position();
        Mode_Inf->target_x = x;
        // 初始速度设为0，避免突变
        now_volx = 0;
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
        lx_step++;
    }
    else if (lx_step == 1)
    {
        float abs_delta = fabs(delta_x);

        // 根据距离动态调整速度
        if (abs_delta > SLOW_DOWN_DIST)
        { // 改动1 x
            // 远距离保持设定速度
            now_volx += 0.2f * (v - now_volx); // 改动1 x // 可调：0~1，越小越平滑 一阶线性滤波
        }
        else if (abs_delta > STOP_DIST)
        {
            // 减速区：速度随距离线性减小
            now_volx += 0.2f * (min_v - now_volx); // 改动1 x
         }
				else
				{
						// 近距离直接锁定位置
						Mode_Inf->target_x = x;
						lx_step = 0; // 重置状态，结束本次控制
						Lock_position_same();
						now_volx = 0; // 确保停止移动
						Position_Control_set_TargetVelocityXY(now_volx, now_voly);
						return true;
				}
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
    }
    return false;
}

/*******************************************
函数名：Move_to_Y
作用：y移动_线性
作者：Lcs
输入参数：float y 目标y位置float v 速度
输出参数：bool 是否到位
封装等级：3
*******************************************/
static bool Move_to_Y(float y, float v, uint8_t clear) // v永远为+正值输入
{
    static uint8_t ly_step = 0;
    float delta_y = y - t265_y;
    float delta_x = Mode_Inf->target_x - t265_x;
    //    now_volx               = delta_x * 1.5;
    // 常量定义（根据实际调试调整）
    //    const float SLOW_DOWN_DIST = 30.0f; // 开始减速的距离阈值
    //    const float STOP_DIST      = 5.0f;  // 完全停止的距离阈值
    //    const float MIN_SPEED      = 3.0f;  // 最小速度限制
    //		const float MAX_ACCEL      = 8.0f;  // 最大加速度限制
    float min_v = MIN_SPEED;
    // 方向处理
    if (delta_y < 0)
    {
        v = -v;
        min_v = -MIN_SPEED;
    }

    if (clear == 1)
        ly_step = 0;

    if (ly_step == 0)
    {
        UnLock_position();
        Mode_Inf->target_y = y;
        now_voly = 0;
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
        ly_step++;
    }
    else if (ly_step == 1)
    {
        float abs_delta = fabs(delta_y);

        // 根据距离动态调整速度
        if (abs_delta > SLOW_DOWN_DIST)
        {
            // 远距离保持设定速度
            now_voly += 0.2f * (v - now_voly); // 改动1 y // 可调：0.01~0.1附近，越小越平滑
            // now_voly = v;
        }
        else if (abs_delta > STOP_DIST)
        {
            // 减速区：速度随距离线性减小
            now_voly += 0.2f * (min_v - now_voly); // 改动1 y // 可调：0.01~0.1附近，越小越平滑
        }
        else
        {
            // 近距离直接锁定位置
            Mode_Inf->target_y = y;
            ly_step = 0;
            Lock_position_same();
            now_voly = 0; // 停止移动
            Position_Control_set_TargetVelocityXY(now_volx, now_voly);
            return true;
        }

        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
    }
    return false;
}


/*******************************************
函数名：Lock_position
作用：锁定位置，主状态机改变
作者：Lcs
输入参数：float x 目标锁定位置，float y 目标锁定位置y
输出参数：bool 返回是否成功
封装等级：4
*******************************************/
static bool Lock_position(float x, float y)
{
    Mode_Inf->position_lock = true;
    Mode_Inf->target_x = x;
    Mode_Inf->target_y = y;
    return true;
}

/*******************************************
函数名：Lock_position_same
作用：锁定原位置
作者：Lcs
输入参数：
输出参数：bool 返回是否成功
封装等级：4
*******************************************/
static bool Lock_position_same()
{
    Mode_Inf->position_lock = true;
    return true;
}

/*******************************************
函数名：Lock_h
作用：锁定高度，主状态机改变
作者：Lcs
输入参数：float height 锁定高度
输出参数：bool 返回是否成功
封装等级：4
*******************************************/
static bool Lock_h(float height)
{
    Mode_Inf->height_lock = true;
    Mode_Inf->target_z = height;
    return true;
}

/*******************************************
函数名：Lock_h_same
作用：锁定原来位置高度
作者：Lcs
输入参数：
输出参数：bool 返回是否成功
封装等级：4
*******************************************/
static bool Lock_h_same()
{
    Mode_Inf->height_lock = true;
    return true;
}

/*******************************************
函数名：Lock_yaw
作用：锁定aim_yaw角
作者：yhc
输入参数： float aim_yaw
输出参数：bool 返回是否成功
封装等级：4
*******************************************/
static bool Lock_yaw(float aim_yaw)
{
    Mode_Inf->yaw_lock = true;
    Mode_Inf->target_yaw = aim_yaw;
    return true;
}

/*******************************************
函数名：Lock_yaw_same
作用：锁定原来yaw角
作者：Lcs
输入参数：
输出参数：bool 返回是否成功
封装等级：4
*******************************************/
static bool Lock_yaw_same()
{
    Mode_Inf->yaw_lock = true;
    return true;
}

/*******************************************
函数名：UnLock_position
作用：解锁位置，主状态机改变
作者：Lcs
输入参数：N
输出参数：bool 返回是否成功
封装等级：4
*******************************************/
static bool UnLock_position()
{
    Mode_Inf->position_lock = false;
    Position_Control_set_TargetPositionXYRelative(0.f, 0.f);
    return true;
}

/*******************************************
函数名：UnLock_h
作用：解锁高度，主状态机改变
作者：Lcs
输入参数：N
输出参数：bool 返回是否成功
封装等级：4
*******************************************/
static bool UnLock_h()
{
    Mode_Inf->height_lock = false;
    Position_Control_set_TargetPositionZRelative(0.f);
    return true;
}

/*******************************************
函数名：UnLock_yaw
作用：解锁yaw角，主状态机改变
作者：Lcs
输入参数：N
输出参数：bool 返回是否成功
封装等级：4
*******************************************/
static bool UnLock_yaw()
{
    Mode_Inf->yaw_lock = false;
    return true;
}

/*******************************************
函数名：ALL_Enable
作用：初始化ControlSystem中的各种控制授权
作者：Lcs
输入参数：无
输出参数：无
封装等级：3
*******************************************/
static void ALL_Enable()
{
    Position_Control_Enable(); // 位置控制使能
    Altitude_Control_Enable(); // 高度控制使能
}

//				// >>> 关键：速度平滑（一阶低通滤波）<<<
//        // 时间常数 tau 控制平滑程度（单位：毫秒，需根据控制频率调整）
//        // 假设控制频率为 100Hz (dt=10ms)，tau=200ms → alpha = dt/(tau+dt) ≈ 0.05
//        const float alpha = 0.05f; // 可调：0.02~0.1，越小越平滑
//        now_volx = now_volx + alpha * (target_vx - now_volx);
//        now_voly = now_voly + alpha * (target_vy - now_voly);
//        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
/*******************************************
函数名：Move_to_XYLine_coll
作用：xy平面最短距离移动_线性 内部协作函数，用于内部对函数的调用
作者：Lcs
输入参数：float x 目标x位置 float y 目标y位置 float v 速度 float detail 要求精度
输出参数：uint8_t 是否到位 1 粗到位 2 细到位
封装等级：3
*******************************************/
static uint8_t Move_to_XYLine_coll(float x, float y, float v, float detail)
{
    uint8_t fanhui = 0;
    static uint8_t l_step = 0;
    float delta_x = x - t265_x;
    float delta_y = y - t265_y;
    float distance = sqrt(delta_x * delta_x + delta_y * delta_y);
    if (distance < 10)
    {
        fanhui = 1;
    }
    else if (distance < 20)
    {
        fanhui = -1;
    }

    if (l_step == 0)
    {
        UnLock_position();
        Mode_Inf->target_x = x;
        Mode_Inf->target_y = y;
        l_step++;
    }
    else if (l_step == 1)
    {
        UnLock_position();
        Mode_Inf->target_x = x;
        Mode_Inf->target_y = y;
        if (distance > 55)
        {
            float delta_vx = now_volx - v * delta_x / distance;
            float delta_vy = now_voly - v * delta_y / distance;

            if (fabs(delta_vx) > 22)
            {
                now_volx = now_volx - 20 * sign_f(delta_vx) * fabs(delta_x / distance);
            }
            else
            {
                now_volx = v * delta_x / distance;
            }

            if (fabs(delta_vy) > 22)
            {
                now_voly = now_voly - 20 * sign_f(delta_vy) * fabs(delta_y / distance);
            }
            else
            {
                now_voly = v * delta_y / distance;
            }
        }

        else if (distance > detail)
        {
            float delta_vx = now_volx - delta_x;
            float delta_vy = now_voly - delta_y;
            if (fabs(delta_vx) > 22)
            {
                now_volx = now_volx - 20 * sign_f(delta_vx) * fabs(delta_x / distance);
            }
            else
            {
                now_volx = delta_x;
            }
            if (fabsf(now_volx) < 10)
            {
                now_volx = delta_x * 3;
            }
            else if (fabsf(now_volx) < 20)
            {
                now_volx = delta_x * 2;
            }
            if (fabs(delta_vy) > 22)
            {
                now_voly = now_voly - 20 * sign_f(delta_vy) * fabs(delta_y / distance);
            }
            else
            {
                now_voly = delta_y;
            }
            if (fabsf(now_voly) < 10)
            {
                now_voly = delta_y * 3;
            }
            else if (fabsf(now_voly) < 20)
            {
                now_voly = delta_y * 2;
            }
        }
        else
        {
            Mode_Inf->target_x = x;
            Mode_Inf->target_y = y;
            l_step = 0;
            Lock_position_same();
            Lock_h_same();
            fanhui = 2;
        }
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
    }

    return fanhui;
}

/*******************************************
函数名：Move_to_XYLine_smoth_coll
作用：xy平面最短距离移动_线性
作者：Lcs
输入参数：float x 目标x位置 float y 目标y位置 float v 速度 detail定点精细度
输出参数：bool 是否到位
封装等级：3
*******************************************/
static int8_t Move_to_XYLine_smoth_coll(float x, float y, float v, float detail)
{
    static uint8_t l_step = 0;
    float delta_x = x - t265_x;
    float delta_y = y - t265_y;
    float distance = sqrt(delta_x * delta_x + delta_y * delta_y);
    int8_t smothend = 10;

    if (distance < 10)
    {
        smothend = 1;
    }
    else if (distance < 20)
    {
        smothend = 2;
    }

    if (l_step == 0)
    {
        UnLock_position();
        Mode_Inf->target_x = x;
        Mode_Inf->target_y = y;
        l_step++;
    }
    else if (l_step == 1)
    {
        UnLock_position();
        Mode_Inf->target_x = x;
        Mode_Inf->target_y = y;
        if (distance > 30)
        {
            float delta_vx = now_volx - v * delta_x / distance;
            float delta_vy = now_voly - v * delta_y / distance;

            if (fabs(delta_vx) > 5)
            {
                now_volx = now_volx - 5 * sign_f(delta_vx) * fabs(delta_x / distance);
            }
            else
            {
                now_volx = v * delta_x / distance;
            }

            if (fabs(delta_vy) > 5)
            {
                now_voly = now_voly - 5 * sign_f(delta_vy) * fabs(delta_y / distance);
            }
            else
            {
                now_voly = v * delta_y / distance;
            }
        }

        else if (distance > detail)
        {
            float delta_vx = now_volx - delta_x;
            float delta_vy = now_voly - delta_y;
            if (fabs(delta_vx) > 7)
            {
                now_volx = now_volx - 5 * sign_f(delta_vx) * fabs(delta_x / distance);
            }
            else
            {
                now_volx = delta_x; // 20 * delta_x / distance;
            }
            if (fabsf(now_volx) < 10)
            {
                now_volx = 2.5 * delta_x;
            }
            else if (fabsf(now_volx) < 20)
            {
                now_volx = 2 * delta_x;
            }
            if (fabs(delta_vy) > 7)
            {
                now_voly = now_voly - 5 * sign_f(delta_vy) * fabs(delta_y / distance);
            }
            else
            {
                now_voly = delta_y; // 20 * delta_y / distance;
            }
            if (fabsf(now_voly) < 10)
            {
                now_voly = 2.5 * delta_y;
            }
            else if (fabsf(now_voly) < 20)
            {
                now_voly = 2 * delta_y;
            }
        }
        else
        {
            Mode_Inf->target_x = x;
            Mode_Inf->target_y = y;
            l_step = 0;
            Lock_position_same();
            Lock_h_same();
            smothend = 0;
        }
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
    }

    return smothend;
}

/*******************************************
函数名：Move_xyz
作用：xyz位置移动
作者：Lcs
输入参数：float x 目标端点x,float y 目标端点y.float z目标端点z, float v 移动速度
输出参数：int8_t 返回精确程度
封装等级：3
*******************************************/
static uint8_t Move_xyz(float x, float y, float z, float v)
{
    uint8_t fanhui = 0;
    static uint8_t l_step = 0;
    float delta_x = x - t265_x;
    float delta_y = y - t265_y;
    float delta_z = z - t265_z;
    float distance = sqrt(delta_x * delta_x + delta_y * delta_y + delta_z * delta_z);

    if (distance < 10)
    {
        fanhui = 1;
    }
    else if (distance < 20)
    {
        fanhui = -1;
    }

    if (l_step == 0)
    {
        UnLock_position();
        UnLock_h();
        Mode_Inf->target_x = x;
        Mode_Inf->target_y = y;
        Mode_Inf->target_z = z;
        l_step++;
    }
    else if (l_step == 1)
    {
        UnLock_position();
        UnLock_h();
        Mode_Inf->target_x = x;
        Mode_Inf->target_y = y;
        Mode_Inf->target_z = z;

        if (distance > 55)
        {
            // 远距离移动，使用方向向量乘以速度
            float delta_vx = now_volx - v * delta_x / distance;
            float delta_vy = now_voly - v * delta_y / distance;
            float delta_vz = now_volz - v * delta_z / distance;

            // X方向速度控制
            if (fabs(delta_vx) > 22)
            {
                now_volx = now_volx - 20 * sign_f(delta_vx) * fabs(delta_x / distance);
            }
            else
            {
                now_volx = v * delta_x / distance;
            }

            // Y方向速度控制
            if (fabs(delta_vy) > 22)
            {
                now_voly = now_voly - 20 * sign_f(delta_vy) * fabs(delta_y / distance);
            }
            else
            {
                now_voly = v * delta_y / distance;
            }

            // Z方向速度控制
            if (fabs(delta_vz) > 10)
            {
                now_volz = now_volz - 8 * sign_f(delta_vz) * fabs(delta_z / distance);
            }
            else
            {
                now_volz = v * delta_z / distance;
            }
        }
        else if (distance > 6)
        {
            // 中距离移动，使用比例控制
            float delta_vx = now_volx - delta_x;
            float delta_vy = now_voly - delta_y;
            float delta_vz = now_volz - delta_z;

            // X方向速度控制
            if (fabs(delta_vx) > 22)
            {
                now_volx = now_volx - 20 * sign_f(delta_vx) * fabs(delta_x / distance);
            }
            else
            {
                now_volx = delta_x;
            }
            if (fabsf(now_volx) < 10)
            {
                now_volx = delta_x * 3;
            }
            else if (fabsf(now_volx) < 20)
            {
                now_volx = delta_x * 2;
            }

            // Y方向速度控制
            if (fabs(delta_vy) > 22)
            {
                now_voly = now_voly - 20 * sign_f(delta_vy) * fabs(delta_y / distance);
            }
            else
            {
                now_voly = delta_y;
            }
            if (fabsf(now_voly) < 10)
            {
                now_voly = delta_y * 3;
            }
            else if (fabsf(now_voly) < 20)
            {
                now_voly = delta_y * 2;
            }

            // Z方向速度控制
            if (fabs(delta_vz) > 10)
            {
                now_volz = now_volz - 8 * sign_f(delta_vz) * fabs(delta_z / distance);
            }
            else
            {
                now_volz = delta_z;
            }
            if (fabsf(now_volz) < 5)
            {
                now_volz = delta_z * 2.5;
            }
            else if (fabsf(now_volz) < 10)
            {
                now_volz = delta_z * 1.8;
            }
        }
        else
        {
            // 到达目标位置
            Mode_Inf->target_x = x;
            Mode_Inf->target_y = y;
            Mode_Inf->target_z = z;
            l_step = 0;
            Lock_position_same();
            Lock_h_same();
            fanhui = 2;
        }

        // 设置速度
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
        Position_Control_set_TargetVelocityZ(now_volz);
    }

    return fanhui;
}

/*******************************************
函数名：Land
作用：降落
作者：Lcs
输入参数：float v 速度
输出参数：bool 是否落地
封装等级：3
*******************************************/
static bool Land(float v)
{
    UnLock_h();
    UnLock_position();
    Mode_Inf->target_z = -1;

    now_volx = (Mode_Inf->target_x - t265_x) * 2;
    now_voly = (Mode_Inf->target_y - t265_y) * 2;

    if (t265_z > 25.0f)
    {
        if (now_volz > -v)
        {
            vol = -2;
            now_volz = now_volz + vol;
        }

        Position_Control_set_TargetVelocityZ(now_volz);
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
    }
    else if (t265_z > -20.0f)
    {
        if (now_volz < -20.0f)
        {
            now_volz = now_volz + 1;
        }
        else
        {
            now_volz = -20;
        }
        Position_Control_set_TargetVelocityZ(now_volz);
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
        if ((fabsf(get_VelocityENU().z)) < 5 && t265_z < 20.0f)
        {
            set_inFlight_false();
            PWM_PullDownAll();
						return true;
        }
    }

    return false;
}

static bool Landstop(float v)
{
    UnLock_h();
    UnLock_position();
    Mode_Inf->target_z = -1;

    now_volx = (Mode_Inf->target_x - t265_x) * 2;
    now_voly = (Mode_Inf->target_y - t265_y) * 2;

    if (t265_z > 25.0f)
    {
        if (now_volz > -v)
        {
            vol = -2;
            now_volz = now_volz + vol;
        }

        Position_Control_set_TargetVelocityZ(now_volz);
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
    }
    else if (t265_z > -20.0f)
    {
        if (now_volz < -20.0f)
        {
            now_volz = now_volz + 1;
        }
        else
        {
            now_volz = -20;
        }
        Position_Control_set_TargetVelocityZ(now_volz);
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
        if ((fabsf(get_VelocityENU().z)) < 5 && t265_z < 20.0f)
        {
            set_inFlight_false();
            Mode_Inf->zt++;
            // PWM_PullDownAll();可以直接拉低
        }
    }

    return false;
}

/*******************************************
函数名：Takeoff_Initial
作用：起飞初始化函数
作者：Lcs
输入参数：float height 需要的高度
输出参数：bool 是否起飞到预定要微调的位置
封装等级：3
*******************************************/
static bool Takeoff_Initial(float height)
{
    static int t_step = 0;
    switch (t_step)
    {
    case 0:
    {
        // Position_Control_Takeoff_HeightRelative(get_Position().z + height);
        set_inFlight_true();
        t_step++;
        break;
    }
    case 1:
    {
        if (get_is_inFlight() == true)
        {
            Mode_Inf->zt++;
            t_step = 0;
        }
        break;
    }
    }
    return true;
}
static bool FlyAgain(float v)
{
    static int t_step = 0;
    switch (t_step)
    {
    case 0:
    {
        /* 关键修改点1：清零所有速度控制变量 */
        now_volx = 0;
        now_voly = 0;
        now_volz = 0; // 清除Landstop设置的下降速度

        /* 关键修改点2：重置控制器目标速度（与变量同步） */
        Position_Control_set_TargetVelocityXY(0, 0);
        Position_Control_set_TargetVelocityZ(0);

        /* 保持原有逻辑 */
        set_inFlight_true();
        t_step++;
        break;
    }
    case 1:
    {
        /* 保持原有状态切换逻辑 */
        if (get_is_inFlight() == true)
        {
            Mode_Inf->zt++;
            t_step = 0;
        }
        break;
    }
    }
    return true;
}

 

/*******************************************
函数名：Takeoff_h_45d
作用：仅由高度控制的45度角起飞
作者：Lcs
输入参数：float height 你所想要的高度 uint8_t sign_x 起飞时的x向坐标 uint8_t sign_y 起飞时的y向坐标 v 起飞速度
输出参数：bool 是否起飞到预定要微调的位置
封装等级：3
*******************************************/
static bool Takeoff_h_45d(float height, uint8_t sign_x, uint8_t sign_y, float v)
{
    // 可能要加unlock h/position
    static uint8_t h_step = 0;
    float delta_x = t265_x - Mode_Inf->target_x;
    float delta_y = t265_y - Mode_Inf->target_y;
    float distance = sqrt(Mode_Inf->target_x * Mode_Inf->target_x + Mode_Inf->target_y * Mode_Inf->target_y + Mode_Inf->target_z * Mode_Inf->target_z);
    if (h_step == 0)
    {
        Mode_Inf->target_x = height * (sign_x / sqrt(sign_x * sign_x + sign_y * sign_y));
        Mode_Inf->target_y = height * (sign_y / sqrt(sign_x * sign_x + sign_y * sign_y));
        Mode_Inf->target_z = height;
        h_step++;
    }
    else if (h_step == 1)
    {
        if (t265_z < 10)
        {
            now_volx = (0 - t265_x) * 1.5;
            now_voly = (0 - t265_y) * 1.5;
            Position_Control_set_TargetVelocityZ(40);
            Position_Control_set_TargetVelocityXY(now_volx, now_voly);
            now_volz = 40;
        }
        else
        {
            if (t265_z < height - 30)
            {
                float delta_vx = now_volx - v * delta_x / distance;
                float delta_vy = now_voly - v * delta_y / distance;
                if (fabs(delta_vx) > 7)
                {
                    now_volx = now_volx - 10 * sign_f(delta_vx) * fabs(delta_x / distance);
                }
                else
                {
                    now_volx = v * delta_x / distance;
                }

                if (fabs(delta_vy) > 7)
                {
                    now_voly = now_voly - 10 * sign_f(delta_vy) * fabs(delta_y / distance);
                }
                else
                {
                    now_voly = v * delta_y / distance;
                }
            }
            else if (t265_z < height - 10)
            {
                float delta_vx = now_volx - 20 * delta_x / distance;
                float delta_vy = now_voly - 20 * delta_y / distance;
                if (fabs(delta_vx) > 7)
                {
                    now_volx = now_volx - 10 * sign_f(delta_vx) * fabs(delta_x / distance);
                }
                else
                {
                    now_volx = v * delta_x / distance;
                }

                if (fabs(delta_vy) > 7)
                {
                    now_voly = now_voly - 10 * sign_f(delta_vy) * fabs(delta_y / distance);
                }
                else
                {
                    now_voly = v * delta_y / distance;
                }
            }
            else
            {
                Lock_h_same();
                Lock_position_same();
                h_step = 0;
                Mode_Inf->zt++;
            }
        }
    }

    return true;
}
/*******************************************
函数名：Rotate
作用：自旋到固定角度
作者：Lcs
输入参数：float aim_yaw 目标角度 float v_yaw 角速度
输出参数：bool 是否到位
封装等级：3
*******************************************/
static bool Rotate(float aim_yaw, float v_yaw)
{
    Mode_Inf->target_yaw = aim_yaw;

    float now_yaw = Quaternion_getYaw(get_Airframe_attitude());

    float delta_yaw = Mode_Inf->target_yaw - now_yaw;

    if (fabsf(aim_yaw - now_yaw) > 0.02)
    {
        Attitude_Control_set_Target_Yaw(aim_yaw);
        return false;
    }
    else
    {
        Attitude_Control_set_Target_Yaw(aim_yaw);
        yaw_liscence = false;
        Mode_Inf->target_yaw = aim_yaw;

        Lock_yaw_same();

        return true;
    }
}

/*******************************************
函数名：Move_Z
作用：Z位置改变
作者：Lcs
输入参数：float z 目标z位置 float v 速度
输出参数：bool 是否到位
封装等级：3
*******************************************/
static bool Move_Z(float z, float v)
{
    static int8_t h_step = 0;
    float delta_z = z - t265_z;
    if ((delta_z)*v < 0)
    {
        v = -v;
    }
    now_volx = (Mode_Inf->target_x - t265_x) * 5;
    now_voly = (Mode_Inf->target_y - t265_y) * 5;
    if (h_step == 0)
    {
        UnLock_position();
        UnLock_h();
        Mode_Inf->target_z = z;
        Lock_position_same();
        h_step++;
    }
    else if (h_step == 1)
    {
        if (fabs(delta_z) > 20)
        {
            float delta_vz = now_volz - v;
            if (fabs(delta_vz) > 5)
            {
                now_volz = now_volz - 4 * sign_f(delta_vz);
            }
            else
            {
                now_volz = v;
            }
        }
        else if (fabs(delta_z) > 10)
        {
            now_volz = delta_z;
        }
        else
        {
            Mode_Inf->target_z = z;
            h_step = 0;
            Lock_position_same();
            Lock_h(z);
            Mode_Inf->zt++;
        }
        Position_Control_set_TargetVelocityZ(now_volz);
    }
    Position_Control_set_TargetPositionXY(now_volx, now_voly);
    return true;
}

/*******************************************
函数名：RotateToYaw
作用：改变yaw角度
作者：yhc
输入参数：float aim_yaw目标角度, float max_yaw_rate最大角速度
输出参数：bool 是否到位
封装等级：3
*******************************************/
static bool RotateToYaw(float aim_yaw, float max_yaw_rate)
{
    float now_yaw = Quaternion_getYaw(get_Airframe_attitude());
    // 保证yaw在0~2π范围
    if (now_yaw < 0)
        now_yaw += 2 * Pi;
    if (aim_yaw < 0)
        aim_yaw += 2 * Pi;

    float delta_yaw = aim_yaw - now_yaw;
    // 处理环绕，保证在-π~π
    while (delta_yaw > Pi)
        delta_yaw -= 2 * Pi;
    while (delta_yaw < -Pi)
        delta_yaw += 2 * Pi;

    const float yaw_threshold = 0.1f; // 约5度

    if (fabsf(delta_yaw) > yaw_threshold)
    {
        // 旋转方向和速度
        float set_rate = (delta_yaw > 0 ? 1.0f : -1.0f) * max_yaw_rate;
        Attitude_Control_set_Target_YawRate(set_rate);
        return false; // 还未到达目标
    }
    else
    {
        // 到达目标角度，切换为角度锁定
        yaw_liscence = false;
        Attitude_Control_set_Target_Yaw(aim_yaw);
        Lock_position_same();
        Lock_h_same();
        Lock_yaw_same();
        return true; // 已到达目标
    }
}

/*******************************************
函数名：land_45d       （未完成版）
作用：45度角降落
作者：yhc
输入参数：float height降落时的高度uint8_t sign_x 降落时的x向坐标 uint8_t sign_y 降落时的y向坐标 v 起飞速度
输出参数：bool 是否降落到预定要微调的位置
封装等级：3
*******************************************/
static bool land_45d(float height, uint8_t sign_x, uint8_t sign_y, float v)
{
    // 可能要加unlock h/position
    static uint8_t h_step = 0;
    float delta_x = t265_x - Mode_Inf->target_x;
    float delta_y = t265_y - Mode_Inf->target_y;
    float distance = sqrt(Mode_Inf->target_x * Mode_Inf->target_x + Mode_Inf->target_y * Mode_Inf->target_y + Mode_Inf->target_z * Mode_Inf->target_z);
    if (h_step == 0)
    {
        Mode_Inf->target_x = height * (sign_x / sqrt(sign_x * sign_x + sign_y * sign_y));
        Mode_Inf->target_y = height * (sign_y / sqrt(sign_x * sign_x + sign_y * sign_y));
        Mode_Inf->target_z = height;
        h_step++;
    }
    else if (h_step == 1)
    {
        if (t265_z < 10)
        {
            now_volx = (0 - t265_x) * 1.5;
            now_voly = (0 - t265_y) * 1.5;
            Position_Control_set_TargetVelocityZ(40);
            Position_Control_set_TargetVelocityXY(now_volx, now_voly);
            now_volz = 40;
        }
        else
        {
            if (t265_z < height - 30)
            {
                float delta_vx = now_volx - v * delta_x / distance;
                float delta_vy = now_voly - v * delta_y / distance;
                if (fabs(delta_vx) > 7)
                {
                    now_volx = now_volx - 10 * sign_f(delta_vx) * fabs(delta_x / distance);
                }
                else
                {
                    now_volx = v * delta_x / distance;
                }

                if (fabs(delta_vy) > 7)
                {
                    now_voly = now_voly - 10 * sign_f(delta_vy) * fabs(delta_y / distance);
                }
                else
                {
                    now_voly = v * delta_y / distance;
                }
            }
            else if (t265_z < height - 10)
            {
                float delta_vx = now_volx - 20 * delta_x / distance;
                float delta_vy = now_voly - 20 * delta_y / distance;
                if (fabs(delta_vx) > 7)
                {
                    now_volx = now_volx - 10 * sign_f(delta_vx) * fabs(delta_x / distance);
                }
                else
                {
                    now_volx = v * delta_x / distance;
                }

                if (fabs(delta_vy) > 7)
                {
                    now_voly = now_voly - 10 * sign_f(delta_vy) * fabs(delta_y / distance);
                }
                else
                {
                    now_voly = v * delta_y / distance;
                }
            }
            else
            {
                Lock_h_same();
                Lock_position_same();
                h_step = 0;
                // Mode_Inf->zt++;
            }
        }
    }

    return true;
}


static int8_t Takeoff(float x, float y, float z, float v)
{
 
    int8_t xyz_fanhui = -100;
    float delta_x = x - t265_x;
    float delta_y = y - t265_y;
    float delta_z = z - t265_z;
    static int8_t xyz_step = 0;

    if (delta_x < 20 && delta_y < 20 && delta_z < 5)
    {
        xyz_fanhui = -1;
    }
    else if (delta_x < 10 && delta_y < 10 && delta_z < 5)
    {
        xyz_fanhui = 1;
    }

    if (xyz_step == 0)
    {
        UnLock_h();
        UnLock_position();
        Mode_Inf->target_x = x;
        Mode_Inf->target_y = y;
        Mode_Inf->target_z = z;
        xyz_step++;
    }
    else if (xyz_step == 1)
    {
        UnLock_h();
        UnLock_position();

        /*//lhq:fabsf处理float类型的取绝对值*/
        if (fabsf(delta_x) > 0.7 * v)
        { // 0.6介稳飞行
            float delta_vx = now_volx - v * sign_f(delta_x);

            if (fabs(delta_vx) > 33)
            {
                now_volx = now_volx - 30 * sign_f(delta_vx);
            }
            else
            {
                now_volx = v * sign_f(delta_x);
            }
        }
        else
        {
            float delta_vx = now_volx - delta_x;

            if (fabs(delta_vx) > 33)
            {
                now_volx = now_volx - 30 * sign_f(delta_vx);
            }
            else
            {
                now_volx = delta_x;
            }
            if (now_volx < 10)
            {
                now_volx = 2 * delta_x;
            }
            else if (now_volx < 20)
            {
                now_volx = 1.5 * delta_x;
            }
        }
        if (fabsf(delta_y) > 0.7 * v)
        { // 0.6介稳飞行

            float delta_vy = now_voly - v * sign_f(delta_y);

            if (fabs(delta_vy) > 33)
            {
                now_voly = now_voly - 30 * sign_f(delta_vy);
            }
            else
            {
                now_voly = v * sign_f(delta_y);
            }
        }
        else
        {
            float delta_vy = now_voly - delta_y;

            if (fabs(delta_vy) > 33)
            {
                now_voly = now_voly - 30 * sign_f(delta_vy);
            }
            else
            {
                now_voly = delta_y;
            }
            if (now_voly < 10)
            {
                now_voly = 2 * delta_y;
            }
            else if (now_voly < 20)
            {
                now_voly = 1.5 * delta_y;
            }
        }
        if (fabsf(delta_z) > 35)
        {
            if (v > 80)
            {
                v = 80;
            }
            float delta_vz = now_volz - v * sign_f(delta_z);

            if (fabs(delta_vz) > 4)
            {
                now_volz = now_volz - 4 * sign_f(delta_vz);
            }
            else
            {
                now_volz = v * sign_f(delta_z);
            }
        }
        else
        {
            float delta_vz = now_volz - delta_z;

            if (fabs(delta_vz) > 4)
            {
                now_volz = now_volz - 4 * sign_f(delta_vz);
            }
            else
            {
                now_volz = delta_z; // lhq 原来  now_volz = delta_z;      ->0.4 *
            }

            if (now_volz < 10)
            {
                now_volz = 1.8 * delta_z; // 原来是2
            }
            else if (now_volz < 20)
            {
                now_volz = 1.3 * delta_z;
            } // lhq6/13
        }

        Position_Control_set_TargetVelocityZ(now_volz);
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);

        if (fabsf(delta_x) < 4 && fabsf(delta_y) < 4 && fabsf(delta_z) < 5) // 445
        {
            xyz_step++;
        }
    }
    else if (xyz_step == 2)
    {
        Lock_position(x, y);
        Lock_h(z);
        xyz_step = 0;
        xyz_fanhui = 2;
        // Mode_Inf->zt++;
    }

    return xyz_fanhui;
}

/*******************************************
函数名：Takeoff_h
作用：起飞到指定高度，xy方向锁死； 非常重要：起飞稳定后 Mode_Inf->zt++;状态自加1 ！！！！！！！！
输入参数：float height高度, int v起飞速度
输出参数：bool 是否延时结束
封装等级：5
*******************************************/
static bool Takeoff_h(float height, int v)
{
    float position_base = 10;  // 初始响应高度（加速高度的判决，由飞机底盘决定）
    int vol_limit_takeoff = v; // 起飞加速度限制，由飞机重量决定

    //	    Mode_Inf->target_x = 0;
    //	    Mode_Inf->target_y = 0;
    Lock_position(25.0f, 25.0f);

    //	    now_volx = (Mode_Inf->target_x - t265_x) * 1.5;
    //	    now_voly = (Mode_Inf->target_y - t265_y) * 1.5;

    if (t265_z <= position_base)
    {
        Position_Control_set_TargetVelocityZ(60);
        //			Position_Control_set_TargetVelocityXY(now_volx, now_voly);
        now_volz = 60;
    }
    else if (t265_z < height - 4 * position_base)
    {
        //		    Position_Control_set_TargetVelocityXY(now_volx, now_voly);
        Position_Control_set_TargetVelocityZ(now_volz + vol);
        if (now_volz < vol_limit_takeoff)
        {
            now_volz = now_volz + vol;
        }
        else
        {
            now_volz = now_volz - vol;
        }
    }
    else if (t265_z < height - 5)
    {
        float now_positon = height - t265_z;
        //		    Position_Control_set_TargetVelocityXY(now_volx, now_voly);
        Position_Control_set_TargetVelocityZ(4.0 * now_positon / 3.0);
        now_volz = 4.0 * now_positon / 3.0;
    }
    else
    {
        Lock_h(height);
        Lock_position(25.0f, 25.0f);
        Mode_Inf->zt++;
        return true;
    }
    return false;
}
```