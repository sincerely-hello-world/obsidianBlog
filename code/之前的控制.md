```cpp
//------------------------------------------------------------
// 以下为所需函数
/*******************************************
函数名：Move_to_XYLine
作用：xy平面最短距离移动_线性
作者：Lcs
输入参数：float x 目标x位置 float y 目标y位置 float v 速度
输出参数：bool 是否到位
封装等级：3
*******************************************/
static bool Move_to_XYLine(float x, float y, float v)
{
    static uint8_t l_step = 0;
    float delta_x         = x - t265_x;
    float delta_y         = y - t265_y;
    float distance        = sqrt(delta_x * delta_x + delta_y * delta_y);

    if (l_step == 0) {
        UnLock_position();
        Mode_Inf->target_x = x;
        Mode_Inf->target_y = y;
        l_step++;
    } else if (l_step == 1) {
        if (distance > 54) {
            float delta_vx = now_volx - v * delta_x / distance;
            float delta_vy = now_voly - v * delta_y / distance;

            if (fabs(delta_vx) > 22) {
                now_volx = now_volx - 20 * sign_f(delta_vx) * fabs(delta_x / distance);
            } else {
                now_volx = v * delta_x / distance;
            }

            if (fabs(delta_vy) > 22) {
                now_voly = now_voly - 20 * sign_f(delta_vy) * fabs(delta_y / distance);
            } else {
                now_voly = v * delta_y / distance;
            }
        }

        else if (distance > 7) {
            float delta_vx = now_volx - delta_x;
            float delta_vy = now_voly - delta_y;
            if (fabs(delta_vx) > 22) {
                now_volx = now_volx - 20 * sign_f(delta_vx) * fabs(delta_x / distance);
            } else {
                now_volx = delta_x; // 20 * delta_x / distance;
            }
            if (fabsf(now_volx) < 10) {
                now_volx = delta_x * 3;
            } else if (fabsf(now_volx) < 20) {
                now_volx = delta_x * 2;
            }
            
            if (fabs(delta_vy) > 22) {
                now_voly = now_voly - 20 * sign_f(delta_vy) * fabs(delta_y / distance);
            } else {
                now_voly = delta_y; // 20 * delta_y / distance;
            }
            if (fabsf(now_voly) < 10) {
                now_voly = delta_y * 3;
            } else if (fabsf(now_voly) < 20) {
                now_voly = delta_y * 2;
            }
        } else {
            Mode_Inf->target_x = x;
            Mode_Inf->target_y = y;
            l_step             = 0;
            Lock_position_same();
            Lock_h_same();
            // Mode_Inf->zt++;
            return true;
        }
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
    }
    return false;
}
/*******************************************
函数名：Move_to_X
作用：x移动_线性
作者：Lcs
输入参数：float x 目标x位置float v 速度
输出参数：bool 是否到位
封装等级：3
*******************************************/
static bool Move_to_X(float x, float v, uint8_t clear)
{
    static uint8_t lx_step = 0;
    float delta_x          = x - t265_x;
    float delta_y          = Mode_Inf->target_y - t265_y;
    now_voly               = delta_y * 1.5;

    // 常量定义（根据实际调试调整）
    const float SLOW_DOWN_DIST = 30.0f; // 开始减速的距离阈值
    const float STOP_DIST      = 5.0f;  // 完全停止的距离阈值
    const float MIN_SPEED      = 3.0f;  // 最小速度限制
    const float MAX_ACCEL      = 8.0f;  // 最大加速度限制

    // 方向处理
    if (v * delta_x < 0) {
        v = -v;
    }

    if (clear == 1)
        lx_step = 0;

    if (lx_step == 0) {
        UnLock_position();
        Mode_Inf->target_x = x;
        // 初始速度设为0，避免突变
        //now_volx = 0;
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
        lx_step++;
    } else if (lx_step == 1) {
        float abs_delta    = fabs(delta_x);
        float target_speed = 0;

        // 根据距离动态调整速度
        if (abs_delta > SLOW_DOWN_DIST) {
            // 远距离保持设定速度
            target_speed = v;
        } else if (abs_delta > STOP_DIST) {
            // 减速区：速度随距离线性减小
            float speed_ratio = abs_delta / SLOW_DOWN_DIST;
            target_speed      = sign_f(delta_x) * fmaxf(MIN_SPEED, fabs(v) * speed_ratio);
        } else {
            // 近距离直接锁定位置
            Mode_Inf->target_x = x;
            lx_step            = 0;
            Lock_position_same();
            now_volx = 0; // 确保停止移动
            Position_Control_set_TargetVelocityXY(now_volx, now_voly);
            return true;
        }

        // 平滑加速/减速
        float speed_diff = target_speed - now_volx;
        if (fabs(speed_diff) > MAX_ACCEL) {
            now_volx += sign_f(speed_diff) * MAX_ACCEL;
        } else {
            now_volx = target_speed;
        }

        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
    }
    return false;
}

/*******************************************
函数名：Move_to_Y
作用：y移动_线性
作者：Lcs
输入参数：float y 目标y位置float v 速度
输出参数：bool 是否到位
封装等级：3
*******************************************/
static bool Move_to_Y(float y, float v, uint8_t clear)
{
    static uint8_t ly_step = 0;
    float delta_y          = y - t265_y;
    float delta_x          = Mode_Inf->target_x - t265_x;
    now_volx               = delta_x * 1.5;
    // 常量定义（根据实际调试调整）
    const float SLOW_DOWN_DIST = 30.0f; // 开始减速的距离阈值
    const float STOP_DIST      = 5.0f;  // 完全停止的距离阈值
    const float MIN_SPEED      = 2.0f;  // 最小速度限制

    // 方向处理
    if ( delta_y < 0) {
        v = -v;
    }

    if (clear == 1)
        ly_step = 0;

    if (ly_step == 0) {
        UnLock_position();
        Mode_Inf->target_y = y;
        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
        ly_step++;
    } else if (ly_step == 1) {
        float abs_delta = fabs(delta_y);

        // 根据距离动态调整速度
        if (abs_delta > SLOW_DOWN_DIST) {
            // 远距离保持设定速度
            now_voly = v;
        } else if (abs_delta > STOP_DIST) {
            // 减速区：速度随距离线性减小
            float speed_ratio = abs_delta / SLOW_DOWN_DIST;
            now_voly          = sign_f(delta_y) * fmaxf(MIN_SPEED, fabs(v) * speed_ratio);
        } else {
            // 近距离直接锁定位置
            Mode_Inf->target_y = y;
            ly_step            = 0;
            Lock_position_same();
            now_voly = 0; // 停止移动
            Position_Control_set_TargetVelocityXY(now_volx, now_voly);
            return true;
        }

        Position_Control_set_TargetVelocityXY(now_volx, now_voly);
    }
    return false;
}
```